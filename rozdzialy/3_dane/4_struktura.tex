\section{Tworzenie struktury grafu}
\sectionauthor{Jan Kruczyński}
\label{sec:data-files}
Celem tego etapu jest wytworzenie plików na których operuje aplikacja. Podczas projektowania ich struktury wzięliśmy pod uwagę, że muszą one:
\begin{enumerate}
    \item Zawierać w sobie pełną informację na temat struktury skierowanego grafu połączeń pomiędzy kolejnymi węzłami.
    \item Rozróżniać czy dany węzeł reprezentuje artykuł czy kategorię.
    \item Przechowywać tytuły z Wikipedii każdego węzła.
    \item Przechowywać ID strony na Wikipedii.
    \item Umożliwiać szybkie odnajdywanie interesujących nas danych o konkretnym węźle bez przeszukiwania wszystkich plików za każdym razem, gdy potrzebujemy wydobyć jakąś informację.
    \item Przechowywać dane w skompresowanej formie, bez zbędnych bajtów i redundantnej informacji.
\end{enumerate}

Struktura owych plików powinna dać nam możliwość funkcjonowania aplikacji, bez trzymania wszystkich danych w pamięci tymczasowej. Odczytywanie danych z plików powinno być możliwie najszybsze.

\subsection{Generowanie brakujących danych}
\label{sec:generating-missing-files}

Dane linków zawierają wyłącznie połączenia typu ``z węzła - do innego węzła'', ale nie mają połączeń odwrotnych ``do węzła z innych węzłów''. Aby aplikacja była w stanie zaprezentować pełny skierowany graf połączeń potrzebne jest odwzorowanie odwrotne. Do finalnego poprawnego generowania plików potrzebne są dodatkowe pliki:
\begin{itemize}
    \item Artykuły które prowadzą do konkretnego artykułu (odwrotność \textit{pagelinks.map})
    \item Kategorie do których należy dany artykuł (odwrotność categorylinksfrompage.map)
    \item Kategorie do których należy dana kategoria (odwrotność categorylinksfromcategory.map)
\end{itemize}

Dane których potrzebujemy nie znajdziemy w plikach SQL, lecz posiadając opisane w sekcji 3.3 pliki \textit{.map} jesteśmy na ich podstawie wygenerować brakujące nam informacje.
Aby to zrobić, odczytujemy interesujący nas plik .map i czytając linia po linii wypełniamy Dictionary o następującej formie:

\begin{lstlisting}[caption={Dictionary przechowujące odwzorowanie odwrotne}, label=lst:reverse-map]
Dictionary<int, List<string>> reverseMap = new Dictionary<int, List<string>>();
\end{lstlisting}

Jako, że pliki .map są uporządkowane według ID, aby osiągnąć ten sam efekt, dictionary zdefiniowany w Listingu \ref{lst:reverse-map} została umieszczona w strukturze SortedDictionary a następnie zapisana w pliku o odpowiedniej nazwie. 
Klucz w dictionary to ID Wikipedii danego artykułu lub kategorii (w zależności od pliku \textit{.map} który przetwarzamy) jest typu int, aby umożliwić łatwe sortowanie za pomocą SortedDictionary. Wartość danego klucza to lista powiązanych połączeń, analogiczna do pliku źródłowego \textit{.map}. Jako, że nie ma potrzeby rzutowania na typ numeryczny - odczytujemy i zapisujemy typ string, lista przechowuje w sobie wartości takiego typu.

\subsection{Opis poszczególnych plików}
Aby osiągnąć wymagania które sobie postawiliśmy, opracowaliśmy strukturę rozbitą na 4 pliki. Wszystkie posiadają tą samą nazwę - jest to nazwa wersji Wikipedii którą opisują (np. simple-wiki lub pl-wiki), a różnią się rozszerzeniami - gdyż każdy plik posiada inną strukturę.

\begin{itemize}
    \item
\textbf{Plik mapy \textit{.wgm}}\newline

Jest to plik instruujący aplikację na którym miejscu w innych plikach odnajdzie interesujące nas dane.
Każdy węzeł zawiera swój wpis w pliku .map zajmując dokładnie 12 bajtów o strukturze opisanej w Tablicy \ref{tab:structure-mapfile}. Offset informuje nas, od którego bajtu w danym pliku możemy odczytywać informację o danym węźle.

\tabela{
 \hline
 4 bajty & 4 bajty & 4 bajty \\ [0.5ex] 
 \hline\hline
 Offset w pliku \textit{.wgg} & Offset w pliku \textit{.wgt} & ID Wikipedii \\\hline
}{|c | c | c|p{0.4\textwidth}| }{Reprezentacja pojedynczego węzła w pliku \textit{.wgm}}{structure-mapfile}

W tym miejscu następuje swoiste przekonwertowanie ID Wikipedii danej strony na “nasze” ID - czyli kolejność danego węzła w pliku .map. W aplikacji oraz w pozostałych plikach, gdy odnosimy się do jakiegoś węzła nie używamy jego faktycznego ID wikipedii, tylko właśnie tą kolejność - licząc od zera. Znając ją, możemy pomnożyć ją przez rozmiar każdego wpisu (12) i otrzymujemy Offset w pliku \textit{.wgm}. Podczas konstrukcji plików, informacje o danym węźle są jednocześnie umieszczane we wszystkich plikach. Dzięki temu nie ma potrzeby przechowywać danej informującej ile bajtów należy odczytać. Odczytu należy dokonać aż do pozycji Offset który znajduje się w następnym węźle z pliku \textit{.wgm} - czyli 12 bajtów dalej.

\item
\textbf{Plik struktury grafu \textit{.wgg}}

Jest to plik zawierający dane połączeń skierowanego grafu. Rozróżniane są połączenia: (\#1) od których węzłów możemy dojść do aktualnego węzła oraz (\#2) do których węzłów prowadzi nasz węzeł. Struktura użyta w tym pliku jest opisana w Tablicy \ref{tab:structure-graphfile}.

\tabela{
 \hline
 2 bajty & 3 bajty * N & 3 bajty * X \\ [0.5ex] 
 \hline\hline
 Ilość połączeń typu (\#1) (N) & a\#1 b\#2 c\#3 … z\#N & A\#1 B\#2 C\#3 … Z\#X \\\hline
}{|c | c | c|p{0.4\textwidth}| }{Reprezentacja pojedynczego węzła w pliku \textit{.wgg}}{structure-graphfile}

A, B, C oraz a, b, c to nie są ID artykułów Wikipedii, lecz informacje, który z kolei artykuł z pliku .wgm mamy na myśli. Jako że ilość węzłów nigdy nie przekracza $2^{24}$, 3 bajty wystarczają na przekazanie tej informacji.

\item
\textbf{Plik informacyjny .wgi}

Zawiera wyłącznie jedną liczbę typu int - jest to ilość artykułów które znajdują się w plikach. Jest to jedyne rozróżnienie dla aplikacji który węzeł traktować jako artykuł, a który jako kategorię - w pozostałych plikach nie ma pomiędzy nimi rozróżnienia. Do plików najpierw zapisujemy wszystkie artykuły, a dopiero potem kategorie, dzięki czemu od pewnego momentu aplikacja oznacza węzły do których pobierana jest informacja jako kategorię. 

\item
\textbf{Plik tytułów .wgt}

Zawiera w sobie zapisane w formacie UTF-8 tytuły wszystkich artykułów i kategorii.
\end{itemize}

\subsection{Metoda generowania plików}

Program generujący pliki .wgX został napisany w języku C\#.
Program zawiera kilka pomocniczych struktur ułatwiających konstrukcję wynikowych plików:
\newline
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Pomocnicze struktury dla programu generującego pliki dla aplikacji}, label=lst:graph-object]
Dictionary<int, int> pageMap;%*\label{line:pageMap}*)
Dictionary<int, int> categoryMap;%*\label{line:categoryMap}*)

public class GraphObject
{
    public bool isArticle;%*\label{line:go-article}*)
    public int id;%*\label{line:go-id}*)
    public string title;%*\label{line:go-title}*)
    public int offsetTitle;%*\label{line:go-offsetTitle}*)
    public int offsetGraph;%*\label{line:go-offsetGraph}*)
    public int order;%*\label{line:go-order}*)
}
\end{lstlisting}
\end{minipage}

Są to dictionary przechowujące odwzorowanie ID z Wikipedii (\ref{line:go-id}) (który to reprezentuje dany węzeł w plikach \textit{.map}) na kolejność węzła w pliku \textit{.wgm} (tzw. ``nasze ID’’ (\ref{line:go-order})). Jako, że kategorie oraz artykuły mogą posiadać takie samo ID Wikipedii potrzebne na to są dwie oddzielne struktury (linie \ref{line:pageMap} oraz \ref{line:categoryMap} ).

W pierwszej kolejności program wywołuje metodę generującą odwzorowania odwrotne dla każdego z trzech plików wymagających tego, zgodnie z metodą opisaną w rozdziale 3.4.1.

Następnie program zlicza ilość linii w pliku zawierającym tytuły artykułów i zapisuję tą liczbę do pliku \textit{.wgi}. Jednocześnie zapełnia dictionary pageMap. Po tym etapie odczytuje tytuły kategorii i wypełnia categoryMap w analogiczny sposób.\newline
Kolejnym etapem jest już faktyczne zapisanie danych o węźle do wszystkich plików. Aby zachować taką samą kolejność węzłów w plikach ponownie odczytujemy plik tytułów dla artykułów, parsujemy informacje o nim do struktury reprezentującej go w programie (Listing \ref{lst:graph-object}) i zapisujemy odpowiednie dane do każdego z plików.
\newline
